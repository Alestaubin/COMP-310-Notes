## Os History: IBM 701
- IBM's first commercially-available, stored-program mainframe computer.
- Used for scientific computation (aircraft, nuclear explosives).
- First AI program : checkers
- Unlike the ENIAC, the IBM 701 was a **stored-program** computer. 
- Programs were fed in via punch cards. 
- No operating system.
- **batch processing** system. Multiple jobs were put on the same tape, and executed one after the other; thus reducing idle time.
- But manual intervention by human operators was often required between jobs and to supervise the jobs.

### OS control flow
1. `trap` is generated by cpu when there's an error (divide by 0, illegal access). "involuntary syscall", transfers control to kernel.
2. `interrupt` is generated by a device needing attention (disk i/o completed, packet arrived from network). Also an "involuntary syscall".

The OS is an **event-driven** program. It **only runs** when a trap, interrupt or system call is generated.

### Trap and return from trap
They do the following (all at once):
- jump into kernel code (or process code, for return-from-trap) 
- change the processor mode (user to kernel, or kernel to user) 
- load the kernel stack (or process stack, for return-from-trap).

### Limited direct execution #execution 
when a process wants to do something sensitive, it issues a system call, which enters into the OS and then comes back using a return-from-trap. Once done, the process **exit**s, which also traps back into the OS.

## OS structure
1. monolithic OS
	Entire OS is in kernel. This is not good.
2. microkernels 
	Absolute minimum in kernel, rest in user mode. Have failed commercially. 
3. system programs

## Process operation 
A process does two things: 
- either it computes (using the CPU
- or it does I/O (using a device)
1. single process system
	- A system where only a single process can run at a time, very **inefficient** 
	- CPU is idle a lot of the time. 
	- can't do anything while a process is running.
2. multi process system
	- While a process waits for an I/O request to complete, **another process** can use the CPU!
	two important considerations: • 
	- how to switch between processes, and 
	- how to determine which process to run (scheduling).
#### How can the OS regain control of the CPU to switch to another process? 
1.  non-preemptive scheduling ("cooperative multitasking") 
	The OS trusts processes to behave responsibly. 
	Special syscall **yield** lets the process give back control to the CPU...when it wants. 
	Note: if the program performs an illegal operation (e.g., bad memory access), OS also regains control. 
	Used in early versions of Mac OS
	**A process could run forever**
2. preemptive scheduling (noncooperative)
	**Timer interrupts**. A timer device can be programmed to raise an interrupt every so often, at which point the process is forcibly paused and the OS executes an interrupt handler, regaining control.
#### How can the OS switch back to the original process?
- A process consists of: Code (including libraries), Stack, Heap, Registers (including PC), MMU info.
- The kernel maintains an array of **process control blocks** (PCB) which contains information about current processes, including: Process identifier (unique id), Process state, Space to support process switch (save area). 
- The PCB array is indexed by a hash of the PID.
- A process switch is an **expensive** operation! Requires saving and restoring lots of stuff.
### Scheduling
- OS **scheduler** decides when to run a ready process. 
- If a ready process is run, we say it has been **scheduled**. 
- Or if it is running and moves to ready, we say it has been **de-scheduled**.
##### Metrics of scheduling
- **Scheduling policy:** determines which ready process will be scheduled next.
- **Workload:** set of running processes.
- **Turnaround time**: the time it takes for a job to complete.
- **Response time**: the difference between the time the job arrives and the time it is first scheduled.
- **Fairness**: who gets the resources? We want an equitable division of resources.
- **Starvation**: how bad can it get? Lack of progress by some job.
- **Overhead**: how much useless work? Time wasted switching between jobs.
- **Predictability**: how consistent?  Low variance in response time for repeated requests.

Types of jobs: 
Interactive = you are waiting for the result 
- E.g., browser, editor, … 
- Tend to be short 
- A good scheduler for this job has a short response time
Batch = you will look at result later 
- E.g., supercomputing center, offline analysis, … 
- Tend to be long
- A good scheduler for this job has a high throughput (# of jobs completed)

### Algorithms: 
- FIFO (First In, First out) 
	Jobs are executed by the time they arrived in the system. (They are inserted at tail of queue.)
	Low overhead – few scheduling events 
	Good throughput 
	Uneven response time – stuck behind long job 
	Extreme case – process monopolizes CPU
- SJF (Shortest Job First) 
	SJF is an optimal scheduling algorithm **if** all jobs arrive at the same time.
- STCF (Shortest Time To Completion First) 
	Each time a new job comes in, STCF schedules the job with the least amount of time left.
- Round-robin
	run a job for a **time slice** (scheduling quantum),then switch to the next job in the queue (the one that hasn't been run for the longest amount of time).
	Good compromise for long and short jobs 
	Short jobs finish quickly (a few rounds) 
	Long jobs are not postponed forever 
	No need to know job length 
	Typical time slice = 10 milliseconds
	Too small: Many scheduling events, Good response time, Low throughput Too large: Few scheduling events, Good throughput, Poor response time